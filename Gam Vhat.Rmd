---
title: "R Notebook"
output: html_notebook
---

```{r}

```

```{r}


#setup multitheading
library(doParallel)

cores = detectCores()


```


```{r}

library(dplyr)
library(tidymodels)
library(usemodels)
## Assume you save the training data in the folder "C:/temp" in your local laptop
traindata <- read.table(file = "C:/temp/7406train.csv", sep=",");
dim(traindata);
## dim=10000*202
## The first two columns are X1 and X2 values, and the last 200 columns are the Y valus

### Some example plots for exploratory data analysis
### please feel free to add more exploratory analysis
testX  <- read.table(file = "C:/temp/7406test.csv", sep=",")
names(traindata)[names(traindata) == 'V1'] = 'X1'
names(traindata)[names(traindata) == 'V2'] = 'X2'
names(testX)[names(testX) == 'V1'] = 'X1'
names(testX)[names(testX) == 'V2'] = 'X2'
X1 <- traindata[,1];
X2 <- traindata[,2];

## note that muhat = E(Y) and Vhat = Var(Y)
muhat <- apply(traindata[,3:202], 1, mean);
Vhat  <- apply(traindata[,3:202], 1, var)

data0 = data.frame(X1 = X1, X2=X2, muhat = muhat, Vhat = Vhat)


```



```{r}
#tidy models learning stuff

set.seed(123)


#splitting data
split = initial_split(data0)
train = training(split)
test = testing(split)

set.seed(234)
folds = bootstraps(train)

```




```{r}
library(splines)


```


```{r}
# Recipe with polynomial features and interaction
Vhat_spline_rec <- recipe(Vhat ~ X1 + X2, data = train) %>%
  step_poly(X1, degree = tune("x1_degree")) %>%  # Polynomial for X1
  step_poly(X2, degree = tune("x2_degree")) %>%  # Polynomial for X2
  step_interact(terms = ~ starts_with("X1"):starts_with("X2"))  # Interaction

# Model specification
lm_spec <- linear_reg() %>% 
  set_engine("lm")  # Use glmnet or stan if needed

# Workflow
Vhat_spline_wf <- workflow() %>%
  add_recipe(Vhat_spline_rec) %>%
  add_model(lm_spec)

# Tuning grid
spline_grid <- expand.grid(
  x1_degree = c(1:15), 
  x2_degree = c(1:15)
)

# Register parallel backend
doParallel::registerDoParallel()

# Control for saving predictions
save_preds <- control_grid(save_pred = TRUE)

# Tuning
spline_vhat <- tune_grid(
  Vhat_spline_wf,
  resamples = folds,
  grid = spline_grid,
  control = save_preds
)

# Stop parallel processing
doParallel::stopImplicitCluster()

# Evaluate Results
collect_metrics(spline_vhat)
show_best(spline_vhat, metric = "rmse")
```

```{r}
Best_Vhat = select_best(spline_vhat, metric = 'rmse')
Best_Vhat
```


```{r}
Final_V = finalize_workflow(Vhat_spline_wf, Best_Vhat )
Final_V
```


```{r}
V_spline_test = last_fit(Final_V, split)
collect_metrics(V_spline_test)
```

```{r}

Final_V <- extract_workflow(V_spline_test)

predicted_variance = predict(Final_V, new_data = testX)


predicted_variance

```

